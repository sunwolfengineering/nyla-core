
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>db: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sunwolfengineering/nyla-core/pkg/db/db.go (83.3%)</option>
				
				<option value="file1">github.com/sunwolfengineering/nyla-core/pkg/geo/geo.go (0.0%)</option>
				
				<option value="file2">github.com/sunwolfengineering/nyla-core/pkg/handlers/handlers.go (89.7%)</option>
				
				<option value="file3">github.com/sunwolfengineering/nyla-core/pkg/handlers/ui.go (0.0%)</option>
				
				<option value="file4">github.com/sunwolfengineering/nyla-core/pkg/hash/hash.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package db

import (
        "context"
        "database/sql"
        "log"
        "strconv"
        "time"

        "github.com/mileusna/useragent"
        _ "modernc.org/sqlite"

        "github.com/sunwolfengineering/nyla-core/pkg/constants"
)

type Event struct {
        AnonID      string
        SiteID      string
        CreatedAt   int32
        Type        string
        Event       string
        Referrer    string
        IsTouch     bool
        BrowserName string
        OSName      string
        DeviceType  string
        Country     string
        Region      string
        Timestamp   time.Time
}

type Events struct {
        DB *sql.DB
}

func (e *Events) Open() error <span class="cov8" title="1">{
        db, err := sql.Open("sqlite", "nyla.db")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">e.DB = db
        return nil</span>
}

func (e *Events) Add(payload interface{}, hash string, ua useragent.UserAgent, geo interface{}) error <span class="cov8" title="1">{
        q := `
        INSERT INTO events
        (
                anon_id,
                site_id, 
                created_at, 
                type, 
                event, 
                referrer,
                is_touch, 
                browser_name, 
                os_name,
                device_type, 
                country, 
                region
        ) VALUES (
                ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
        )
        `

        // Always use the default site ID for single-site architecture
        _, err := e.DB.ExecContext(
                context.Background(),
                q,
                hash,
                constants.DefaultSiteID, // Always use default site
                nowToInt(),
                "pageview", // Default type for now - should be extracted from payload
                "", // URL - should be extracted from payload
                "", // Referrer - should be extracted from payload
                "false", // is_touch
                ua.Name, 
                ua.OS, 
                "not-implemented", // device_type
                "not-implemented", // country
                "not-implemented", // region
        )

        return err
}</span>

func (e *Events) Close() error <span class="cov8" title="1">{
        if e.DB != nil </span><span class="cov8" title="1">{
                return e.DB.Close()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func nowToInt() uint32 <span class="cov8" title="1">{
        now := time.Now().Format("20060102")
        i, err := strconv.ParseInt(now, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">return uint32(i)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package geo

import (
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "os"
        "strings"
)

var (
        GEOIP_PROTO = getEnv("GEOIP_PROTO", "http")
        GEOIP_HOST  = getEnv("GEOIP_HOST", "localhost:8080")
)

func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value, exists := os.LookupEnv(key); exists </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

type GeoInfo struct {
        IP         string `json:"ip"`
        Country    string `json:"country"`
        CountryISO string `json:"country_iso"`
        RegionName string `json:"region_name"`
        RegionCode string `json:"region_code"`
        City       string `json:"city"`
        Latitude   string `json:"latitude"`
        Longitude  string `json:"longitude"`
}

func IPFromRequest(headers []string, r *http.Request) (net.IP, error) <span class="cov0" title="0">{
        remoteIP := ""
        for _, h := range headers </span><span class="cov0" title="0">{
                remoteIP = r.Header.Get(h)
                if http.CanonicalHeaderKey(h) == "X-Forwarded-For" </span><span class="cov0" title="0">{
                        remoteIP = ipFromForwardedForHeader(remoteIP)
                }</span>
                <span class="cov0" title="0">if remoteIP != "" </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if remoteIP == "" </span><span class="cov0" title="0">{
                host, _, err := net.SplitHostPort(r.RemoteAddr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">remoteIP = host</span>
        }

        <span class="cov0" title="0">ip := net.ParseIP(remoteIP)
        if ip == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid IP %s", remoteIP)
        }</span>
        <span class="cov0" title="0">return ip, nil</span>
}

func ipFromForwardedForHeader(v string) string <span class="cov0" title="0">{
        sep := strings.Index(v, ",")
        if sep == -1 </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return v[:sep]</span>
}

func GetGeoInfo(ip string) (*GeoInfo, error) <span class="cov0" title="0">{
        req, err := http.NewRequest("GET", fmt.Sprintf("%s://%s/json?ip=%s", GEOIP_PROTO, GEOIP_HOST, ip), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var info GeoInfo
        err = json.NewDecoder(resp.Body).Decode(&amp;info)
        return &amp;info, err</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "log"
        "net/http"

        "github.com/chasefleming/elem-go"
        "github.com/chasefleming/elem-go/attrs"
        "github.com/mileusna/useragent"

        "github.com/sunwolfengineering/nyla-core/pkg/constants"
        "github.com/sunwolfengineering/nyla-core/pkg/db"
        "github.com/sunwolfengineering/nyla-core/pkg/geo"
        "github.com/sunwolfengineering/nyla-core/pkg/hash"
)

type CollectorData struct {
        Type      string `json:"type"`
        Event     string `json:"event"`
        UserAgent string `json:"ua"`
        Hostname  string `json:"hostname"`
        Referrer  string `json:"referrer"`
}

type CollectorPayload struct {
        Data CollectorData `json:"data"`
}

type Handlers struct {
        Events *db.Events
}

func (h *Handlers) GetCollectV1(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Parse query parameters
        siteID := r.URL.Query().Get("site_id")
        eventType := r.URL.Query().Get("type")
        url := r.URL.Query().Get("url")
        referrer := r.URL.Query().Get("referrer")

        // Enforce single-site architecture
        if siteID != "" &amp;&amp; siteID != constants.DefaultSiteID </span><span class="cov8" title="1">{
                response := map[string]string{
                        "error": "Invalid site_id. This instance only supports site_id='default'",
                }
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(response)
                return
        }</span>

        <span class="cov8" title="1">if eventType == "" </span><span class="cov8" title="1">{
                response := map[string]string{
                        "error": "Missing required parameter: type",
                }
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusBadRequest)
                json.NewEncoder(w).Encode(response)
                return
        }</span>

        <span class="cov8" title="1">payload := CollectorPayload{
                Data: CollectorData{
                        Type:      eventType,
                        Event:     url,
                        UserAgent: r.UserAgent(),
                        Hostname:  r.Host,
                        Referrer:  referrer,
                },
        }

        ua := useragent.Parse(r.UserAgent())
        ip, _ := geo.IPFromRequest([]string{"X-Forwarded-For", "X-Real-IP"}, r)
        hashVal, _ := hash.GeneratePrivateIDHash(ip.String(), r.UserAgent(), r.Host, constants.DefaultSiteID)

        if err := h.Events.Add(payload, hashVal, ua, nil); err != nil </span><span class="cov0" title="0">{
                log.Println("error adding event:", err)
        }</span>

        <span class="cov8" title="1">log.Println("event added", payload)
        w.Header().Set("Content-Type", "image/gif")
        w.Header().Set("Cache-Control", "no-store, no-cache, must-revalidate, proxy-revalidate")
        w.Header().Set("Pragma", "no-cache")
        w.Header().Set("Expires", "0")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte{
                0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x01, 0x00,
                0x01, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
                0xFF, 0xFF, 0xFF, 0x21, 0xF9, 0x04, 0x01, 0x00,
                0x00, 0x00, 0x00, 0x2C, 0x00, 0x00, 0x00, 0x00,
                0x01, 0x00, 0x01, 0x00, 0x00, 0x02, 0x02, 0x44,
                0x01, 0x00, 0x3B,
        })</span>
}

func (h *Handlers) GetStatsRealtimeV1(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        db := h.Events.DB
        var count int
        // Enforce single-site architecture in the query
        err := db.QueryRow("SELECT COUNT(*) FROM events WHERE type = 'pageview' AND site_id = ?", constants.DefaultSiteID).Scan(&amp;count)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                fmt.Fprintf(w, "&lt;div class='error'&gt;Error: %v&lt;/div&gt;", err)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "text/html; charset=utf-8")
        fragment := elem.Div(attrs.Props{"class": "bg-white rounded-lg shadow p-6"},
                elem.Div(attrs.Props{"class": "text-sm text-gray-500"}, elem.Text("Total Pageviews")),
                elem.Div(attrs.Props{"class": "text-2xl font-bold text-indigo-700 mt-2"}, elem.Text(fmt.Sprintf("%d", count))),
        ).Render()
        w.Write([]byte(fragment))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "net/http"

        "github.com/chasefleming/elem-go"
        "github.com/chasefleming/elem-go/attrs"
        "github.com/chasefleming/elem-go/htmx"
)

type UIHandlers struct {
        APIBaseURL string
}

func (h *UIHandlers) DashboardHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        statsURL := h.APIBaseURL + "/v1/stats/realtime"
        html := elem.Html(attrs.Props{attrs.Lang: "en"},
                elem.Head(nil,
                        elem.Meta(attrs.Props{attrs.Charset: "UTF-8"}),
                        elem.Meta(attrs.Props{
                                attrs.Name:    "viewport",
                                attrs.Content: "width=device-width, initial-scale=1.0",
                        }),
                        elem.Title(nil, elem.Text("Nyla Analytics Dashboard")),
                        elem.Script(attrs.Props{attrs.Src: "https://unpkg.com/htmx.org@1.9.12"}),
                        elem.Script(attrs.Props{attrs.Src: "https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"}),
                ),
                elem.Body(attrs.Props{attrs.Class: "bg-gray-50 min-h-screen"},
                        // Header
                        elem.Header(attrs.Props{attrs.Class: "bg-white shadow px-6 py-4 flex items-center justify-between"},
                                elem.Div(attrs.Props{attrs.Class: "text-2xl font-bold text-indigo-700"}, elem.Text("Nyla Analytics")),
                                elem.Nav(nil,
                                        elem.A(attrs.Props{attrs.Href: "#", attrs.Class: "text-gray-600 hover:text-indigo-700 px-3"}, elem.Text("Dashboard")),
                                        elem.A(attrs.Props{attrs.Href: "#", attrs.Class: "text-gray-600 hover:text-indigo-700 px-3"}, elem.Text("Settings")),
                                ),
                        ),
                        // Main flex container
                        elem.Div(attrs.Props{attrs.Class: "flex"},
                                // Sidebar
                                elem.Aside(attrs.Props{attrs.Class: "w-64 bg-white border-r min-h-screen p-6 hidden md:block"},
                                        elem.Nav(attrs.Props{attrs.Class: "space-y-4"},
                                                elem.A(attrs.Props{attrs.Href: "#", attrs.Class: "block text-indigo-700 font-semibold"}, elem.Text("Overview")),
                                                elem.A(attrs.Props{attrs.Href: "#", attrs.Class: "block text-gray-600 hover:text-indigo-700"}, elem.Text("Pages")),
                                                elem.A(attrs.Props{attrs.Href: "#", attrs.Class: "block text-gray-600 hover:text-indigo-700"}, elem.Text("Visitors")),
                                                elem.A(attrs.Props{attrs.Href: "#", attrs.Class: "block text-gray-600 hover:text-indigo-700"}, elem.Text("Settings")),
                                        ),
                                ),
                                // Main content
                                elem.Main(attrs.Props{attrs.Class: "flex-1 p-8"},
                                        elem.H1(attrs.Props{attrs.Class: "text-3xl font-bold mb-6 text-gray-900"}, elem.Text("Dashboard")),
                                        elem.Div(attrs.Props{attrs.Class: "grid grid-cols-1 md:grid-cols-3 gap-6 mb-8"},
                                                // Metric Cards
                                                elem.Div(attrs.Props{
                                                        attrs.Class:    "bg-white rounded-lg shadow p-6",
                                                        htmx.HXGet:     statsURL,
                                                        htmx.HXTrigger: "load, every 30s",
                                                        htmx.HXSwap:    "innerHTML",
                                                },
                                                        elem.Text("Loading..."),
                                                ),
                                                elem.Div(attrs.Props{attrs.Class: "bg-white rounded-lg shadow p-6"},
                                                        elem.Div(attrs.Props{attrs.Class: "text-sm text-gray-500"}, elem.Text("Unique Visitors")),
                                                        elem.Div(attrs.Props{attrs.Class: "text-2xl font-bold text-indigo-700 mt-2"}, elem.Text("--")),
                                                ),
                                                elem.Div(attrs.Props{attrs.Class: "bg-white rounded-lg shadow p-6"},
                                                        elem.Div(attrs.Props{attrs.Class: "text-sm text-gray-500"}, elem.Text("Active Users")),
                                                        elem.Div(attrs.Props{attrs.Class: "text-2xl font-bold text-indigo-700 mt-2"}, elem.Text("--")),
                                                ),
                                        ),
                                        // Chart placeholder
                                        elem.Div(attrs.Props{attrs.Class: "bg-white rounded-lg shadow p-6 h-64 flex items-center justify-center text-gray-400"},
                                                elem.Text("[Traffic Chart Placeholder]"),
                                        ),
                                ),
                        ),
                ),
        ).Render()
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        w.Write([]byte(html))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package hash

import (
        "crypto/sha256"
        "encoding/hex"
        "time"
)

// generateSalt generates a salt string based on the given IP and site ID.
func GenerateSalt(ip, siteID string) string <span class="cov0" title="0">{
        currentDate := time.Now().Format("20060102")
        return ip + "_" + siteID + "_" + currentDate
}</span>

// GeneratePrivateIDHash generates a private ID hash based on the given inputs.
func GeneratePrivateIDHash(ip, userAgent, hostname, siteID string) (string, error) <span class="cov0" title="0">{
        salt := GenerateSalt(ip, siteID)
        data := salt + userAgent + hostname + siteID

        hasher := sha256.New()
        _, err := hasher.Write([]byte(data))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">hash := hex.EncodeToString(hasher.Sum(nil))
        return hash, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
